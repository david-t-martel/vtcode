<!-- Generated by Ruler -->


<!-- Source: .ruler/AGENTS.md -->

# VT Code - Agent Guide

## Build/Test Commands

-   **Build**: `cargo check` (preferred) or `cargo build --release`
-   **Lint**: `cargo clippy` (must pass before commit)
-   **Format**: `cargo fmt`
-   **Test all**: `cargo test` or `cargo nextest run` (preferred)
-   **Test single**: `cargo test test_name` or `cargo nextest run test_name`
-   **Run**: `./run.sh` (release) or `./run-debug.sh` (debug)
-   **Single query**: `cargo run -- ask "your query"` (headless testing)

## Architecture

-   **vtcode-core/**: Library code (LLM providers, tools, config, MCP integration)
-   **src/**: CLI binary (Ratatui TUI, PTY execution, slash commands)
-   **Config**: `vtcode.toml` (never hardcode), constants in `vtcode-core/src/config/constants.rs`, model IDs in `docs/models.json`
-   **Key modules**: `llm/` (provider abstraction), `tools/` (trait-based), `config/` (TOML parsing)
-   **Integration**: Tree-sitter parsers (Rust/Python/JS/TS/Go/Java), MCP tools, PTY command execution

## Code Style

-   **Error handling**: `anyhow::Result<T>` with `.with_context()` for all fallible functions
-   **Naming**: snake_case (functions/vars), PascalCase (types)
-   **Formatting**: 4 spaces, early returns over nested ifs, descriptive variable names
-   **No emojis, no hardcoded values** (read from vtcode.toml/constants.rs)
-   **Docs**: All .md files in `./docs/` only (not root)

## Tool Usage Guidelines

-   **Essential Tools** (Tier 1): read_file, write_file, list_files, grep_file, PTY sessions
-   **Important Tools** (Tier 2): edit_file, git_diff, update_plan
-   **Specialized Tools** (Tier 3): ast_grep_search, apply_patch, delete_file, curl
-   **Advanced Tools** (Tier 4): execute_code, search_tools, save_skill, load_skill, search_skills
-   **Deprecated Tools**: run_terminal_cmd (use PTY session tools instead)
-   **Command Execution**: Always use PTY sessions (create_pty_session, send_pty_input, read_pty_session) for better control
-   **File Editing**: Use edit_file for surgical changes, write_file for full rewrites, apply_patch for complex diffs
-   **Search**: Use grep_file for text search, ast_grep_search for semantic code search

## Code Execution & Skills (High-Impact Features)

### When to Use Code Execution

Use `execute_code()` to:

-   **Filter large datasets** (100+ items) locally in Python/JavaScript sandbox
-   **Transform data** before returning (map, reduce, group operations)
-   **Implement complex logic** (loops, conditionals, error handling)
-   **Chain tools together** in single execution (90% token reduction)
-   **Save patterns as skills** for 80%+ reuse on repeated tasks

### Code Execution Workflow

1. **Discover Tools**: `search_tools(keyword="xyz", detail_level="name-only")` - minimal context
2. **Write Code**: Python 3 or JavaScript calling tools as library functions
3. **Execute**: `execute_code(code=..., language="python3")` - runs in sandbox
4. **Save Pattern**: `save_skill(name="...", code=..., language="...")` for future reuse
5. **Reuse**: `load_skill(name="...")` - instant execution, no re-run

### Safety & Security

-   Sandbox isolation: Cannot escape to filesystem beyond WORKSPACE_DIR
-   PII protection: Sensitive data auto-tokenized before return
-   Timeout enforcement: 30-second max execution
-   Resource limits: Memory and CPU bounded

### Example: Filter 1000 Test Files

**With code execution** (recommended):

```python
files = list_files(path="/workspace", recursive=True)
test_files = [f for f in files if "test" in f and f.endswith(".rs")]
result = {"count": len(test_files), "files": test_files[:20]}
```

### IMPORTANT

-   Don't print API KEY print debug and logging what soever. THIS IS IMPORTANT!
-   Always use code execution for 100+ item filtering (massive token savings)
-   Save skills for repeated patterns (80%+ reuse ratio documented)
